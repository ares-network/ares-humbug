package com.playares.humbug.cont.mods;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketContainer;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.utility.StreamSerializer;
import com.comphenix.protocol.wrappers.nbt.NbtCompound;
import com.comphenix.protocol.wrappers.nbt.NbtFactory;
import com.comphenix.protocol.wrappers.nbt.NbtList;
import com.google.common.base.Charsets;
import com.google.common.collect.Maps;
import com.playares.humbug.HumbugService;
import com.playares.humbug.cont.HumbugMod;
import com.playares.commons.logger.Logger;
import com.playares.commons.util.bukkit.Scheduler;
import com.playares.commons.util.general.Configs;
import com.playares.commons.util.general.Time;
import io.netty.buffer.ByteBuf;
import lombok.Getter;
import lombok.Setter;
import org.bukkit.Bukkit;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.inventory.ItemStack;

import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.util.Map;
import java.util.UUID;

public final class ExploitMod implements HumbugMod, Listener {
    @Getter public final HumbugService humbug;
    @Getter public final String name = "Exploit Fixes";
    @Getter @Setter public boolean enabled;
    @Getter @Setter private boolean listening;
    @Getter private final Map<UUID, Long> lastPackets;

    public ExploitMod(HumbugService humbug) {
        this.humbug = humbug;
        this.enabled = false;
        this.listening = false;
        this.lastPackets = Maps.newConcurrentMap();
    }

    @Override
    public void load() {
        final YamlConfiguration config = Configs.getConfig(humbug.getOwner(), "humbug");

        this.enabled = config.getBoolean("mods.exploit_fixes.enabled");

        if (listening) {
            return;
        }

        ProtocolLibrary.getProtocolManager().addPacketListener(new PacketAdapter(humbug.getOwner(), PacketType.Play.Client.CUSTOM_PAYLOAD) {
            @Override
            public void onPacketReceiving(PacketEvent event) {
                analyze(event);
            }
        });

        Bukkit.getPluginManager().registerEvents(this, humbug.getOwner());

        this.listening = true;
    }

    @Override
    public void unload() {
        PlayerQuitEvent.getHandlerList().unregister(humbug.getOwner());
    }

    /**
     * Handles analyzing packets
     * @param event PacketEvent
     */
    private void analyze(PacketEvent event) {
        final Player player = event.getPlayer();
        final long lastPacket = lastPackets.getOrDefault(player.getUniqueId(), -1L);

        if (lastPacket == -2L) {
            event.setCancelled(true);
            return;
        }

        final String name = event.getPacket().getStrings().readSafely(0);

        if (!name.equals("MC|BSign") && !name.equals("MC|BCEdit") && !name.equals("REGISTER")) {
            return;
        }

        try {
            if (name.equals("REGISTER")) {
                analyzeChannels(event);
            } else {
                if (lastPacket == -1L || Time.now() - lastPacket > 100L) {
                    lastPackets.put(player.getUniqueId(), Time.now());
                } else {
                    throw new IOException("Packet flood");
                }

                analyzeNbt(event);
            }
        } catch (Throwable ex) {
            lastPackets.put(player.getUniqueId(), -2L);

            new Scheduler(humbug.getOwner()).sync(() -> player.kickPlayer("Stop trying to crash a minecraft server you fucking virgin LOL")).run();

            Logger.warn(player.getName() + " is attempting to crash the server with CustomPayload packet flooding");
            event.setCancelled(true);
        }
    }

    /**
     * Handles analyzing packet channels
     * @param event PacketEvent
     * @throws Exception Exception
     */
    private void analyzeChannels(PacketEvent event) throws Exception {
        int channelSize = event.getPlayer().getListeningPluginChannels().size();
        final PacketContainer container = event.getPacket();
        final ByteBuf buffer = container.getSpecificModifier(ByteBuf.class).read(0).copy();

        try {
            for (int i = 0; i < buffer.toString(Charsets.UTF_8).split("\0").length; i++) {
                if (++channelSize > 124) {
                    throw new IOException("Too many channels");
                }
            }
        } finally {
            buffer.release();
        }
    }

    /**
     * Handles analyzing NBT tags
     * @param event PacketEvent
     * @throws IOException Exception
     */
    private void analyzeNbt(PacketEvent event) throws IOException {
        final PacketContainer container = event.getPacket();
        final ByteBuf buffer = container.getSpecificModifier(ByteBuf.class).read(0).copy();
        final byte[] bytes = new byte[buffer.readableBytes()];

        buffer.readBytes(bytes);

        try (DataInputStream inputStream = new DataInputStream(new ByteArrayInputStream(bytes))) {

            final ItemStack item = StreamSerializer.getDefault().deserializeItemStack(inputStream);

            if (item == null) {
                throw new IOException("Unable to deserialize ItemStack");
            }

            final NbtCompound root = (NbtCompound) NbtFactory.fromItemTag(item);

            if (root == null) {
                throw new IOException("No NBT Tag found");
            } else if (!root.containsKey("pages")) {
                throw new IOException("No 'pages' NBT compound was found");
            } else {
                final NbtList<String> pages = root.getList("pages");

                if (pages.size() > 50) {
                    throw new IOException("Too many book pages");
                }
            }
        } finally {
            buffer.release();
        }
    }

    @EventHandler
    public void onPlayerQuit(PlayerQuitEvent event) {
        final Player player = event.getPlayer();
        lastPackets.remove(player.getUniqueId());
    }
}